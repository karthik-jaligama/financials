@using Financials.Data.Classes
@using Microsoft.AspNetCore.Components.Forms
@rendermode InteractiveServer

<div class="related-files-container">
    <!-- Header -->
    <div class="files-header">
        <div class="header-icon">üìÅ</div>
        <h2 class="header-title">Related Files</h2>
    </div>

    <!-- Main content area -->
    <div class="files-content">
        <!-- Drop Zone -->
        <div class="drop-zone-section">
            <FileDropZone OnFilesAdded="HandleFilesAdded" />
        </div>

        <!-- Files Display -->
        @if (Files.Any())
        {
            <div class="files-display">
                @foreach (var file in Files)
                {
                    <FileItem FileData="file" 
                              OnRemove="(id) => HandleRemoveFile(id)" 
                              OnFileUpdated="HandleFileUpdated" />
                }
            </div>
        }
    </div>

    <!-- Instructions -->
    @if (Files.Any())
    {
        <div class="instructions">
            Double-click any file to open it
        </div>
    }
</div>


@code {
    private List<FileData> Files = new();

    private async Task HandleFilesAdded(IBrowserFile[] files)
    {
        foreach (var file in files)
        {
            var fileData = new FileData
            {
                Id = Guid.NewGuid().ToString(),
                Name = file.Name,
                ContentType = file.ContentType,
                Size = file.Size,
                UploadedAt = DateTime.UtcNow
            };

            // Try to read file content into memory, but handle cases where it's not supported
            try
            {
                using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB limit
                using var memoryStream = new MemoryStream();
                await stream.CopyToAsync(memoryStream);
                fileData.Content = memoryStream.ToArray();
            }
            catch (NotImplementedException)
            {
                // This is a MockBrowserFile (from drag-and-drop), so we don't have actual content
                // Just store the metadata - the file reference is enough
                fileData.Content = null;
            }
            catch (Exception ex)
            {
                // Handle other potential errors
                Console.WriteLine($"Error reading file content: {ex.Message}");
                fileData.Content = null;
            }

            Files.Add(fileData);
        }

        StateHasChanged();
    }

    private void HandleRemoveFile(string fileId)
    {
        var fileToRemove = Files.FirstOrDefault(f => f.Id == fileId);
        if (fileToRemove != null)
        {
            Files.Remove(fileToRemove);
            StateHasChanged();
        }
    }

    private void HandleFileUpdated(FileData updatedFile)
    {
        var existingFile = Files.FirstOrDefault(f => f.Id == updatedFile.Id);
        if (existingFile != null)
        {
            // Update the existing file with SharePoint information
            existingFile.SharePointUrl = updatedFile.SharePointUrl;
            existingFile.SharePointDriveItemId = updatedFile.SharePointDriveItemId;
            existingFile.SharePointWebUrl = updatedFile.SharePointWebUrl;
            existingFile.SharePointShareUrl = updatedFile.SharePointShareUrl;
            existingFile.SharePointSiteId = updatedFile.SharePointSiteId;
            existingFile.SharePointLastModified = updatedFile.SharePointLastModified;
            
            StateHasChanged();
        }
    }
}
