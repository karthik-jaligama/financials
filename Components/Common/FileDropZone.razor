@using Financials.Data.Classes
@using Microsoft.AspNetCore.Components.Forms
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div class="file-drop-zone @(IsDragActive ? "drag-active" : "")"
     @onclick="TriggerFileInput">
    
    <InputFile OnChange="HandleFileSelected" multiple class="file-input" @ref="fileInput" />
    
    <div class="drop-zone-content">
        <svg class="download-icon" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7,10 12,15 17,10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        <p class="drop-zone-text">Drag and drop files here or click to browse.</p>
    </div>
</div>

@code {
    [Parameter] public EventCallback<FileData[]> OnFilesAdded { get; set; }
    
    private bool IsDragActive = false;
    private InputFile? fileInput;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Set up drag and drop event listeners using JavaScript
                await JSRuntime.InvokeVoidAsync("setupDragAndDrop", DotNetObjectReference.Create(this));
            }
            catch (InvalidOperationException)
            {
                // Ignore JavaScript interop errors during static rendering
                // The drag and drop functionality will be available after the component becomes interactive
            }
        }
    }

    private async Task TriggerFileInput()
    {
        if (fileInput != null)
        {
            await JSRuntime.InvokeVoidAsync("triggerFileInput", fileInput.Element);
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        if (e.FileCount > 0)
        {
            var fileDataList = new List<FileData>();
            
            foreach (var file in e.GetMultipleFiles())
            {
                // Read the file as a byte array
                var buffer = new byte[file.Size];
                await file.OpenReadStream().ReadAsync(buffer);
                
                // Create blob URL using JavaScript
                var blobUrl = await JSRuntime.InvokeAsync<string>("createBlobUrl", buffer, file.ContentType);
                
                var fileData = new FileData
                {
                    Id = Guid.NewGuid().ToString(),
                    Name = file.Name,
                    Type = file.ContentType,
                    Size = file.Size,
                    UploadDate = DateTime.Now,
                    Url = blobUrl
                };

                fileDataList.Add(fileData);
            }
            
            await OnFilesAdded.InvokeAsync(fileDataList.ToArray());
        }
    }

    [JSInvokable]
    public async Task HandleDroppedFiles(string[] fileNames, byte[][] fileData, string[] contentTypes)
    {
        var fileDataList = new List<FileData>();
        
        for (int i = 0; i < fileNames.Length; i++)
        {
            // Create blob URL using JavaScript
            string blobUrl;
            try
            {
                blobUrl = await JSRuntime.InvokeAsync<string>("createBlobUrl", fileData[i], contentTypes[i]);
            }
            catch (InvalidOperationException)
            {
                // Fallback if JavaScript interop is not available
                blobUrl = $"data:{contentTypes[i]};base64,{Convert.ToBase64String(fileData[i])}";
            }
            
            var fileDataItem = new FileData
            {
                Id = Guid.NewGuid().ToString(),
                Name = fileNames[i],
                Type = contentTypes[i],
                Size = fileData[i].Length,
                UploadDate = DateTime.Now,
                Url = blobUrl
            };

            fileDataList.Add(fileDataItem);
        }
        
        await OnFilesAdded.InvokeAsync(fileDataList.ToArray());
        StateHasChanged();
    }

    [JSInvokable]
    public void SetDragActive(bool active)
    {
        if (IsDragActive != active)
        {
            IsDragActive = active;
            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        // Clean up event listeners only if component is properly initialized
        try
        {
            if (JSRuntime != null)
            {
                await JSRuntime.InvokeVoidAsync("cleanupDragAndDrop");
            }
        }
        catch (InvalidOperationException)
        {
            // Ignore JavaScript interop errors during disposal
            // This can happen during static rendering or when the circuit is disconnected
        }
    }
}
