@using Microsoft.AspNetCore.Components.Web
@using Microsoft.AspNetCore.Components.Forms
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@rendermode InteractiveServer

<div id="@elementId" class="file-drop-zone @(IsDragActive ? "drag-active" : "")"
     @onclick="OpenFileDialog">
    
    <div class="drop-zone-content">
        <div class="drop-icon">üìÅ</div>
        <p class="drop-text">@(IsDragActive ? "Drop files here!" : "Drag and drop files here or click to browse")</p>
    </div>
    
    <InputFile @ref="fileInput" 
               OnChange="HandleFileSelected" 
               multiple 
               style="display: none;" />
</div>


@code {
    [Parameter] public EventCallback<IBrowserFile[]> OnFilesAdded { get; set; }

    private bool IsDragActive = false;
    private InputFile? fileInput;
    private string elementId = Guid.NewGuid().ToString();
    private DotNetObjectReference<FileDropZone>? dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            dotNetRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("initializeFileDropZone", dotNetRef, elementId);
        }
    }

    [JSInvokable]
    public Task SetDragActive(bool isActive)
    {
        IsDragActive = isActive;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public async Task HandleDroppedFiles(object[] fileData)
    {
        try
        {
            Console.WriteLine($"HandleDroppedFiles called with {fileData?.Length ?? 0} files");
            var files = new List<IBrowserFile>();
            
            if (fileData != null)
            {
                foreach (var file in fileData)
                {
                    Console.WriteLine($"Processing file: {file?.GetType().Name}");
                    
                    // Parse the file data directly from the object
                    if (file is System.Text.Json.JsonElement fileDict && 
                        fileDict.ValueKind == System.Text.Json.JsonValueKind.Object)
                    {
                        var name = fileDict.GetProperty("name").GetString() ?? "Unknown";
                        var type = fileDict.GetProperty("type").GetString() ?? "application/octet-stream";
                        var size = fileDict.GetProperty("size").GetInt64();
                        
                        Console.WriteLine($"File: {name}, Type: {type}, Size: {size}");
                        var mockFile = new MockBrowserFile(name, type, size);
                        files.Add(mockFile);
                    }
                }
            }
            
            Console.WriteLine($"Created {files.Count} mock files");
            await OnFilesAdded.InvokeAsync(files.ToArray());
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling dropped files: {ex.Message}");
            Console.WriteLine($"Stack trace: {ex.StackTrace}");
            // Fallback: create a simple file reference
            var fallbackFile = new MockBrowserFile("Dropped File", "application/octet-stream", 0);
            await OnFilesAdded.InvokeAsync(new[] { fallbackFile });
        }
    }

    private async Task OpenFileDialog()
    {
        await JSRuntime.InvokeVoidAsync("eval", "document.querySelector('input[type=\"file\"]').click();");
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        var files = e.GetMultipleFiles().ToArray();
        await OnFilesAdded.InvokeAsync(files);
    }

    public ValueTask DisposeAsync()
    {
        dotNetRef?.Dispose();
        return ValueTask.CompletedTask;
    }

    // Data structure for file information
    private class FileInfo
    {
        public string Name { get; set; } = string.Empty;
        public string Type { get; set; } = string.Empty;
        public long Size { get; set; }
        public long LastModified { get; set; }
    }

    // Mock class to handle dropped files without content
    private class MockBrowserFile : IBrowserFile
    {
        public string Name { get; }
        public DateTimeOffset LastModified { get; }
        public long Size { get; }
        public string ContentType { get; }

        public MockBrowserFile(string name, string contentType, long size)
        {
            Name = name;
            ContentType = contentType;
            Size = size;
            LastModified = DateTimeOffset.UtcNow;
        }

        public Stream OpenReadStream(long maxAllowedSize = 512000, CancellationToken cancellationToken = default)
        {
            throw new NotImplementedException("MockBrowserFile doesn't support stream reading");
        }
    }

}
